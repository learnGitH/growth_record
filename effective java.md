Effective java

第二章：创建和销毁对象

第1条：用静态工厂方法代替构造器

​	我们有一个类，客户端为了获取该类的一个实例，正常情况下我们都会在类加上一个公有的构造器，然后客户端通过new的方式就可以获取该类的实例，我们也可以不提供构造器或者让构造器私有，然后在类内部提供一个静态的工厂方法（和设计模式的工厂方法有些区别），在该方法进行实例化。客户端只需要调用该类的静态工厂方法即可进行实例化。

```
public static Boolean valueOf(boolean a) {
	return b ? Boolean.TRUE : Boolean.FALSE;
}
```

优势：

（1）静态工厂方法与构造器不同的第一大优势在于，它们有名称。

（2）静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象。

（3）静态工厂方法与构造器不同的第三大优势在于，它们可以返回原返回类型的任何子类型的对象。

（4）静态工厂的第四大优势在于，所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值。

（5）静态工厂的第五大优势在于，方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在。

劣势：

(1) 类如果不含公有的或者受保护的构造器,就不能被子类化

(1) 程序员很难发现它们

第2条:遇到多个构造器参数时要考虑使用构造器

​	如果类的构造器或者静态工厂中具有多个参数,设计这种类时,Builder模式就是一种不错的选择.

第3条:用私有构造器或者枚举类型强化Singleton属性

第4条:通过私有构造器强化不可实例化的能力

第5条:优先考虑依赖注入来引用资源

第6条:避免创建不必要的对象

第7条:消除过期的对象引用

第8条:避免使用终结方法和清除方法

第9条:try-with-resources优先于try-finally

第三章:对于所有对象都通用的方法

第10条:覆盖equals时请遵守通用约定

第11条:覆盖eequals时总是要覆盖hashCode

第12条:始终覆盖toString
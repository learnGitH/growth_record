1、单链表翻转

<img src="D:\projectPath\github\java\images\算法\1翻转单链表.png" alt="1翻转单链表" style="zoom:80%;" />

2、链表内指定区间反转

<img src="D:\projectPath\github\java\images\算法\2翻转指定位置的单链表.png" alt="2翻转指定位置的单链表" style="zoom:80%;" />

3、链表中的节点每k个一组翻转

<img src="D:\projectPath\github\java\images\算法\3每k组进行翻转.png" alt="3每k组进行翻转" style="zoom:80%;" />

```
public class Solution {
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    public ListNode reverseKGroup (ListNode head, int k) {
        // write code here
        ListNode prevNode = new ListNode(-1);
        prevNode.next = head;
        ListNode currNode = head;
        ListNode indexNode = head;
        ListNode pprevNode = null;
        int length = 0;
        while(indexNode != null){
            length++;
            indexNode = indexNode.next;
        }
        int groupNumber = length / k;
        for(int i = 1; i <= groupNumber; i++) {
            for(int j = 1; j < k; j++) {
                ListNode tempNode = currNode.next;
                currNode.next = tempNode.next;
                if(pprevNode != null) {
                    tempNode.next = pprevNode.next;
                    pprevNode.next = tempNode;
                } else {
                    tempNode.next = prevNode.next;
                    prevNode.next = tempNode;
                }
                
            }
            pprevNode = currNode;
            currNode = currNode.next;
        }
        return prevNode.next;
    }
}
```

4、合并两个排序的链表

```
public class Solution {
    public ListNode Merge(ListNode list1,ListNode list2) {
        if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        ListNode head = new ListNode(0);
        ListNode root = head;
        while(list1 != null && list2 != null) {
            if(list1.val < list2.val) {
                head.next = list1;
                list1 = list1.next;
            }else {
                head.next = list2;
                list2 = list2.next;
            }
            head = head.next;
        }
        if(list1 == null) {
            head.next = list2;
        }
        if(list2 == null) {
            head.next = list1;
        }
        return root.next;
    }
}
```

链表思路：

1、翻转（需要记录前、后、当前节点）

2、利用快慢指针解决一些环、回文

3、画出关键草稿

4、关键在于核心逻辑要分析出来



词根词缀记忆法：

## 链接：https://pan.baidu.com/s/1xRusCLQjQx7TJ4ymstSe9w

## 密码：2021



一天一算法
